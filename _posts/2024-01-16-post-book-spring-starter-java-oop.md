---
title: "[Book] 스프링 입문을 위한 자바 객체지향의 원리와 이해"
excerpt: ""

categories:
  - Book
tags:
  - Spring
  - Java
  - OOP
last_modified_at: 2024-01-16T00:00:00
---


예제 소스 코드 : [https://github.com/expert0226/oopinspring](https://github.com/expert0226/oopinspring)

저자 블로그 : [https://expert0226.tistory.com](https://expert0226.tistory.com/202?category=479268)

# 2. 자바와 절차적/구조적 프로그래밍

- JRE에는 JVM이 포함되어 패포되고, JDK에는 그 JRE가 포함되어 있다.
    - JDK - 개발 도구
    - JRE - 실행 환경(JVM용 OS)
    - JVM - 가상 머신
- 프로그램은 코드 실행/데이터 저장 두개 영역으로 메모리를 나누어서 사용하고, 객체지향 프로그램에서는 데이터 저장 영역을 스태틱/스택/힙 3개(T모양)로 분할해서 사용한다.(39p)
- 함수와 메서드는 차이가 없지만, 굳이 차이를 두자면 함수는 클래스나 객체와 상관없이 존재하고, 메서드는 반드시 클래스 정의 안에 존재한다는 것이다.
- main() 실행 전 JVM에서의 전처리 작업
    - java.lang 패키지를 스태틱 영역에 배치.
    - import된 패키지를 스태틱 영역에 배치.
    - 프로그램의 모든 클래스를 스태틱 영역에 배치.
    - 중괄호(if문의 중괄호도 포함) 마다 하나의 스택프레임을 스택 영역에 할당.
    - 스택 프레임 내에 메서드 인자를 저장할 변수공간 확보.
    - 실행은 T 영역이 아니라 실행역역에서 함.
    - 메서드 중괄호가 끝나면 스택 영역에서 스택 프레임이 소멸.
- IDE에서 메서드의 스택 프레임은 보여주지만 메서드 내의 if문과 같은 제어문 스택 프레임까지는 보여주지 않는다.
- 지역 변수는 스택 영역에서 일생을 보내며, 특히 스텍 프레임 안에서 일생을 보내고 주기를 같이 한다.
- 클래스 멤버 변수는 스태틱 영역에서 일생을 보내며 JVM 종료까지 존재한다.
- 객체 멤버 변수는 힙 영역에서 일생을 보내며, 가비지 컬렉션에 의해 소멸된다.
- 내부/외부구성이 아닌 서로 다른 스텍 프레임 내의 변수들을 서로 참조 할수 없는 이유는 포인터를 없애기 위해서 인것 같다.
- 전역 변수인 static 변수는 스태틱 영역에 저장되며, 여러곳에서 변경 할수 있으므로 지양하는것이 좋다. 다만 읽기 전용으로 상수값으로 쓰는 것은 괜찮다.
- 멀티 프로세스는 다수의 데이터 영역(T)를 갖는 것이고, 멀티 쓰레드는 스택 영역을 스레드 개수만큼 분할해서 쓰는 것이다.

# 3. 자바와 객체지향

- 추상화란 구체적인 것을 분해해서 관심 영역에 있는 특성만 가지고 재조립 하는 것이다. = 모델링
- 클래스 속성과 객체 속성은 초기화 하지 않아도 기본값(정수:0, 부동소수점형:0.0, 논리형:false, 객체:null)으로 초기화 된다. 하지만 지역변수는 초기화 하지 않으면 쓰레기 값을 갖는다.
- 클래스명은 분류스럽게, 객체 참조 변수명은 유일무이한 사물처럼 작명하라.(Penguin proro = new Penguin();)
- 객체 지향의 상속은 상위 클래스의 특성을 재사용/확장하며 is a 관계가 아니라 명확히는 is a kind of  관계를 만족해야한다.
- 상속받은 클래스의 인스턴스를 생성하면, 슈퍼 클래스와 서브 클래스 각각 인스턴스가 힙 영역에 생성된다.
- 상위 클래스 타입의 객체 참조 변수를 사용하더라도 하위 클래스에서 오버라이딩 한 메서드가 호출된다.(p133)
- UML 접근제어자 표기
    - private : -field
    - default : ~field
    - protected : #field
    - public : +field
    - 정적 속성/메서드 : 밑줄
- private 속성/메서드의 경우 같은 클래스의 객체끼리는 서로 접근가능(e.g. equals, compareTo)
- 접근 제어자 관련 자세한 사항(p135~138)
- 정적 멤버 접근 시에는 클래스명.정적멤버 형식으로 접근하는 것이 일관성 있는 접근 제한과 메모리의 물리적 접근 방식에도 더 유리하다.(p139)


# 4. 자바가 확장한 객체 지향

- 클래스의 기본 생성자는 자바가 자동으로 만들어 주지만, 인자가 있는 생성자를 만들면 기본 생성자를 만들어 주지 않기에 기본 생성자 까지 정의해야 한다.
- 클래스 정보는 해당 클래스가 코드에서 맨 처음 사용될 때 T 메모리의 스태틱 영역에 로딩된다. 따라서 이때 단 한번 해당 클래스의 static 블록이 실행된다.
- {} 블록을 아무 표시 없이 사용하면 클래스의 인스턴스가 생성될 때마다 {}블록이 실행되고, 이는 생성자 실행 전에 실행된다. [https://docs.oracle.com/javase/tutorial/java/javaOO/initial.html](https://docs.oracle.com/javase/tutorial/java/javaOO/initial.html)
- 인터페이스의 변수는 public static final만 가능하지만 자바가 알아서 붙여주기에 생략 가능하다.
- 인터페이스의 메서드도 public abstract를 자바가 붙여주기에 생략 가능하다.
- 람다는 변수에 저장할 수 있는 로직이다.
- 객체 멤버 메서드는 객체마다 힙영역에 만드는 것은 비효율 적이라서 내부적으로 스태틱 영역에 하나만 만들고 내부에서 this로 객체를 넘겨서 호출하게 변경된다.  (p171~172)

# 5. 객체 지향 설계 5원칙 - SOLID

- SRP(Single Responsibility Principle) : 단일 책임 원칙
    - 남자친구, 사원, 아들, 소대원 역할을 하는 “남자” 클래스 하나 대신 각각의 역할을 하는 클래스로 분리.
    - 속성, 메서드, 패키지, 모듈, 컴포넌트, 프레임워크 등에 적용 가능.
- OCP(Open Closed Principle) : 개방 폐쇄 원칙
    - 자동차의 기본기능을 상속받는 마티즈와 소나타로 구성하면, 운전자 입장에서는 변화에 닫혀있고, 자동차 입장에서는 확장에 열려있음.
    - i.e. JDBC 인터페이스.
    - 유연성, 재사용성, 유지보수성에 중요함.
- LSP(Liskov Substitution Principle) : 리스코프 치환 원칙
    - 하위 클래스의 인스턴스는 상위형 객체 참조 변수에 대입해 상위 클래스의 인스턴스 역할을 하는 데 문제가 없어야 한다.
    - 하위 클래스 is a kind of 상위 클래스 - 하위 분류는 상위 분류의 한 종류다.
    - 구현 클래스 is able to 인터페이스 - 구현 분류는 인터페이스 할수 있어야 한다.
- ISP(Interface Segregation Principle) : 인터페이스 분리 원칙
    - 클라이언트는 자신이 사용하지 않는 메서드에 의존관계를 맺으면 안된다.
    - SRP에서 여러 클래스로 나누는 대신 하나의 클래스가 여러 역할을 하는 인터페이스로 나누는 방법을 고려 할수도 있음.
    - 특별한 경우가 아니면 ISP보다 SRP를 사용하는 것이 좋음.
    - 상위 클래스는 풍성하게, 인터페이스는 최소로.
- DIP(Dependency Inversion Principle) : 의존 역전 원칙
    - 고차원 모듈은 저차원 모듈에 의존하면 안된다. 이 두 모듈 모두 다른 추상화된 것에 의존해야 한다.
    - 구체적인 것이 추상화에 의존해야 한다. 반대는 안된다.
    - 자주 변경되는 구체 클래스에 의존하지 마라.
    - 자신보다 변하기 쉬운 것에 의존하던 것을 추상화된 인터페이스나 상위 클래스를 두어 변하기 쉬운것의 변화에 영향받지 않게 하는 것.

# 6. 스프링이 사랑한 디자인 패턴

- 스프링 = OOP 프레임워크
- 어댑터 패턴 - 호출당하는 쪽의 메서드를 호출하는 쪽의 코드에 대응하도록 중간에 변환기를 통해 호출하는 패턴.
- 프록시 패턴 - 서비스의 인터페이스를 정의하고 대리자는 그 인터페이스를 상속하고 서비스를 갖음(합성). 클라이언트는 대리자인지 파악하기도 어려우며 대리자는 실제 서비스 호출 전후에 다른 로직 추가 가능.
- 데코레이터 패턴 - 흐름을 변경하기 위한 프록시 패턴과 다르게 리턴 결과에 변화를 주기위한 패턴. 그외에 구조는 프록시 패턴과 똑같음.
- 싱글턴 패턴 - 인스턴스를 하나만 만들어서 사용하기 위한 패턴.
    - new를 사용하지 못하도록 생성자 private.
    - 유일한 단일 객체를 반환하는 정적 메서드.
    - 유일한 단일 객체를 참조할 정적 참조 변수.
    - 읽기 전용 속성만 사용 권장.
- 템플릿 메서드 패턴 - 상위 클래스에는 공통 로직이 나열된 템플릿 메서드가 있고, 그 내부에서 호출되는 메서드 중 오버라이딩이 강제되는 추상메서드와 선택적으로 오버라이딩 할 수 있는 Hook 메서드를 두는 패턴.
- 팩터리 메서드 패턴 - 오버라이드 된 메서드가 객체를 반환하는 패턴.
- 전략 패턴 - 클라이언트가 전략을 생성해 전략을 실행 할 컨텍스트에 주입하는 패턴. 같은 문제를 전략 패턴은 객체 주입을 사용하고 템플릿 메서드 패턴은 상속을 이용.
- 템플릿 콜백 패턴 - 전략 패턴과 동일하지만 익명 내부 클래스를 사용하기에 전략에 해당하는 클래스 정의가 필요 없음. 단, 익명 클래스를 넘겨줘야 하기에 전략 인터페이스는 필요함. 중복 코드를 컨텍스트로 이동시켜서 더 깔끔하게 리팩터링 가능.

# 7. 스프링 삼각형과 설정 정보

- IoC/DI - 제어의 역전/의존성 주입
    - 객체 내에서 생성한 객체에 의존하지 안하고, 생성할 객체를 외부로부터 주입받게 되므로 제어의 역전.
    - 의존성 - Aggregation/집합관계(전체와 부분이 다른 생명주기), Composition/합성관계(같은 생명주기)
    - 클래스 다이어그램과 시퀀스 다이어그램을 실무에서도 주로 사용하고, 개별 메서드 동작은 액티비티 다이어그램(또는 순서도, 또는 NS차트)을 사용.
    - 속성(setter) 주입보다는 생성자 주입을 선호함. 현실에서는 타이어를 자주 바꿔 끼기에 속성 주입이 더 맞아보이지만 프로그램에서는 한번 주입되면 계속 사용하는 경우가 일반적임.
    - 자동 의존성 주입(@Autowried)은 type 우선 매칭, @Resource는 id 우선 매칭.
    - @Autowired는 스프링 애너테이션, @Resource는 자바 애너테이션.
    - 스프링 프레임 워크 사용하지 않을 것 대비 @Resource 추천, 그리고 xml을 더 추천.
- AOP
    - 로깅, 보안, 트랜잭션 등의 기능이 반복적으로 나타나는 부분인 횡단 관심사.
    - 인터페이스 기반/프록시기반/런타임 기반으로 동작한다.
    - Advice - @Before/@After 등 시점 + 적용할 로직.
    - PointCut - Aspect 적용 위치 지정자.(메서드 선정 알고리즘)
    - JoinPoint - (광의)스프링 프레임워크가 관리하는 빈의 모든 메서드. (협의)호출된 객체의 메서드.
    - Advisor - 한개의 Advice + 한개의 PointCut.
    - Aspect - 여러 Advice + 여러 PointCut.
    - 최근들어 Aspect가 나와서 Advisor 비권장.
- PSA - 일관성 있는 서비스 추상화
    - 어댑터 패턴을 적용해 같은 일을 하는 다수의 기술을 공통의 인터페이스로 제어할수 있게 한 것.

# 부록 A - 스프링 MVC를 이용한 게시판 구축

- PRG 패턴(POST - Redirect - GET) - POST 처리 후 뷰 힌트를 리다이렉트 없이 list URL로 응답하면 브라우저의 주소가 POST write 페이지로 남아있게 되어 새로고침 시 매번 POST 요청을 하게되는 것을 방지하는 패턴.
- @SessionAttribute를 사용해 세션에 등록된 객체는, 수정 POST 요청 시 먼저 파라미터에 바인딩 되고 그 뒤에 POST로 전달된 객체로 업데이트 하기 때문에 여기에 존재하지 않는 필드는 기존 세션 값을 유지하게 된다. 이를 이용해 수정 구현 시 기존 필드값을 클라에 노출시키지(hidden필드) 않고, DB조회도 다시 하지 않으면서 POST를 처리할 수 있다.

# 부록 B - 자바 8 람다와 인터페이스 스펙 변화

- 람다를 지원하기 위해 함수형 인터페이스 등장.
- 람다 - 변수로 사용할 수 있게된 코드 블록.
- 람다에서 로직이 한줄로 표기되는 경우 {} 생략 가능.
- 함수형 인터페이스 - 추상 메서드를 하나만 갖는 인터페이스.
- 람다식 간소화.
    
    ```java
    (int a) -> { return a * a;}
    (a) -> { return a * a;} // 타입 추정
    a -> { return a * a;}   // 소괄호 생략
    a -> a * a              // 중괄호&리턴 동시 생략 필수, 세미콜론 생략
    ```
    
- 람다식 호출인자/반환값으로 사용.
    
    ```java
    @FunctionalInterface
    interface MyFunctionalInterface {
        public abstract int runSomething(int count);
    }
    
    public static void doIt(MyFunctionalInterface mfi) {
        int b = mfi.runSomething(5);
        ...
    }
    
    public static MyFunctionInterface todo() {
        return num -> num * num;
    }
    ```
    
- 자바 8 API에서 제공하는 함수형 인터페이스
- 스트림을 사용하면 How가 아닌 What만을 지정함으로써 함수형 프로그래밍의 장점인 선언적 프로그래밍을 활용할 수 있다.
- 메서드 레퍼런스 종류
    - 인스턴스::인스턴스메서드
    - 클래스::정적메서드
    - 클래스::인스턴스메서드
    
- 생성자 레퍼런스
    
    ```java
    MyClass c = new MyClass();
    Supplier<MyClass> factory = MyClass::new;
    Supplier<MyClass> factory = () -> new MyClass();
    MyClass cc = factory.get();
    ```
    
- 자바 8에서 인터퍼에스에 변화를 주면서도 그 인터페이스를 구현한 기존의 많은 프로그램들의 호환을 위해 인터페이스에 구체 메서드(디폴트), 구체 정적 메서드 선언을 가능하게 했고(i.g. Iterable의 forEach), 이로인해 Function<T, R> 함수형 인터페이스에 andThen, compose, identity등이 가능해졌다.