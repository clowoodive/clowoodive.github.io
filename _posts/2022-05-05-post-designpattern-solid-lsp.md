---
title:  "[디자인 패턴] SOLID - 리스코프 치환 원칙(Liskov Substitution Principle)"
excerpt: "프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 객체로 바꿀 수 있어야 한다"

categories:
  - 디자인 패턴
  - OOP
tags:
  - 디자인 패턴
  - OOP
last_modified_at: 2022-05-05T00:00:00
---


- LSP 정의

> 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 객체로 바꿀 수 있어야 한다.
> 

부모 클래스로 주고받는 코드에서 부모 클래스 대신 자식 클래스로 교체하더라도 논리적으로 문제 없이 동작할수 있게 설계하란 뜻이다.

![solid_lsp1]({{ '/assets/images/solid_lsp1.png' | relative_url }}){: .align-center}

위 다이어그램을 보면 부모 클래스인 자동차를 상속받은 가솔린차, 경유차는 부모 클래스의 속성이나 동작들을 그대로 상속받아도 문제가 없기에 괜찮지만,  만약 “전기차”라는 클래스를 새로 추가하고 자동차를 상속 받는다면 어떻게 될까?

![solid_lsp2]({{ '/assets/images/solid_lsp2.png' | relative_url }}){: .align-center}

전기차는 배터리로 구동되기에 배터리 속성은 추가하면 되지만, “기름을 넣는다”는 동작은 수행 할수 없기에 상속받을 수가 없다. 따라서 부모 클래스인 `자동차`를 `전기차`로는 교체 할수 없는 설계인 것이다.

이 설계를 보완 하려면

- “기름을 넣는다” 라는 동작은 부모 클래스에서 제거하고, 자식 클래스에서 각각에 맞게 구현한다.
- 기름을 넣거나 배터리를 충전하는 동작을 하나로 보고 처리가 가능하도록 부모 클래스 동작을 변경한다.
- 자동차 클래스와 전기차 클래스는 상속 관계를 맺지 않는다.

등의 방법들을 생각해 볼 수 있다.

단편적인 예로 살펴 보았지만 이 원칙은 “부모 클래스를 대신한 자식 클래스가 제대로 동작하기 위해서는 부모 클래스의 계약 사항을 자식 클래스도 그대로 따라야 한다” 라는 의미가 내포되어 있다.
이 계약 사항들에는 부모 클래스의 속성(변수) 의 값의 범위라던지, 던지는 exception 종류, 조건 검사 수준 등등이 포함되기에 언뜻 보면 이해가 쉬운 원칙 같지만 마냥 쉽지만은 않다. 추후에 시간이나면 조금더 자세히 살펴보는 걸로.

<!--

[https://pizzasheepsdev.tistory.com/9](https://pizzasheepsdev.tistory.com/9)

-->